import { Options } from "minify";
import { minify } from "../../util/minify/minify";
import tryToCatch from "try-to-catch";
import tmp, { file } from "tmp";
import fs from "fs-extra";
import path from "path";
import { TCommand } from "../../types";
import { cpSync, getCwdPath } from "../../util";
import chalk from "chalk";

const hidefile = require("hidefile");

const minifyOptions: Options = {
  html: {
    collapseBooleanAttributes: true,
    includeAutoGeneratedTags: true,
    removeAttributeQuotes: true,
    removeComments: true,
    removeRedundantAttributes: true,
    removeScriptTypeAttributes: true,
    removeStyleLinkTypeAttributes: true,
    sortClassName: true,
    useShortDoctype: true,
    collapseWhitespace: true,
  },
  css: {
    compatibility: "*",
  },
  js: {
    ecma: 5,
  },
};

// 遍历文件夹
export const fileDisplay = async (
  filePath: string,
  fileProcess?: (file: string) => void,
  ingores?: string[]
) => {
  const fileNames = await fs.readdir(filePath);
  for (let i = 0; i < fileNames.length; i++) {
    const filename = fileNames[i];
    //获取当前文件的绝对路径
    const fileDir = path.join(filePath, filename);
    const stats = fs.statSync(fileDir);
    const isFile = stats.isFile();
    const isDir = stats.isDirectory();

    if (hidefile.isHiddenSync(fileDir)) {
      fs.removeSync(fileDir);
    } else {
      if (isFile) {
        if (typeof fileProcess === "function") {
          await fileProcess(fileDir);
        }
      }
      if (isDir) {
        if (!ingores?.includes(filename)) {
          //是文件夹，继续递归
          fileDisplay(fileDir, fileProcess);
        }
      }
    }
  }
};

const fileProcess = async (file: string, output?: string) => {
  const [error, data] = await tryToCatch(minify, file, minifyOptions);

  if (error) {
    console.log(chalk.red(error));
  } else {
    try {
      await fs.writeFile(output ? output : file, data);
    } catch (error) {
      console.log(chalk.red(error));
    }
  }
};

const Minify = async (
  file: string = "",
  options: { all: boolean; destination: string; output: string }
) => {
  const { all, destination = "dist", output } = options;
  const ingores = [
    "img",
    "imgs",
    "image",
    "images",
    "node_modules",
    "less",
    "scss",
    "sass",
  ];
  const outputDir = path.resolve(getCwdPath(), destination);
  if (fs.pathExistsSync(outputDir)) {
    fs.removeSync(outputDir);
  }
  if (all) {
    const tmpobj = tmp.dirSync();
    cpSync(getCwdPath(), tmpobj.name);

    fs.mkdirSync(outputDir);

    cpSync(tmpobj.name, outputDir);

    fs.emptyDirSync(tmpobj.name);
    tmpobj.removeCallback();

    fileDisplay(outputDir, fileProcess, ingores);
  } else if (file) {
    const { name, ext } = path.parse(file);
    fileProcess(
      path.resolve(getCwdPath(), file),
      path.resolve(getCwdPath(), output ? output : `${name}.min${ext}`)
    );
  }
};

export const minifyCommad: TCommand = {
  description: "minify js,css and html",
  command: "minify [file]",
  options: [
    {
      command: "-a --all",
      description: "minify all js,css and html",
    },
    {
      command: "-d --destination <dir>",
      description: "destination dir",
    },
    {
      command: "-o --output <outputName>",
      description: "output name",
    },
  ],
  action: Minify,
};
